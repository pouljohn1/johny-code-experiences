---
title: Creating a chat list
description: We will create a UI for the chat list component
---

In this chapter, we'll redesign our layout to include a sidebar with a chat list on the left and chat content as the main area. For now, the main content will remain empty as we focus on building the chat list functionality.

## Prerequisites

First, we need to install some shadcn components. Run this command in your terminal:

```bash
bunx --bun shadcn@latest add sidebar button skeleton
```

If the CLI doesn't install icons automatically, run `bun add lucide-react`.

This creates new components in the `components/ui` folder. Feel free to explore them to see how they're built.

## Cleaning Up the Default Content

Now we need to remove Next.js example web page content. First let's move to `app/page.tsx` and remove everything and leave just simple div component:

```typescript
export default function Home() {
  return (
    <div className="bg-white dark:bg-black">

    </div>
  );
}
```

This will be our chat content area in the future.

## Configuring the Layout

In Next.js, the layout file wraps all page content. Let's add the shadcn sidebar here to display our list of chats.

Open `app/layout.tsx` and replace its content with:

```typescript add={4-5,33-38} remove={32}
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { SidebarProvider } from "@/components/ui/sidebar";
import ChatSidebar from "@/components/ChatSidebar";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children} 
        <SidebarProvider>
          <ChatSidebar />
          <main className="flex-1 overflow-auto bg-white dark:bg-black">
            {children}
          </main>
        </SidebarProvider>
      </body>
    </html>
  );
}
```

You'll see an error about a missing `@/components/ChatSidebar` file. Let's create it!

Create a new file `ChatSidebar.tsx` in the `components/` folder with the following content:

```typescript
import { Sidebar, SidebarContent } from "./ui/sidebar";

export default function ChatSidebar() {
  return (
    <Sidebar>
      <SidebarContent>
        Hello Sidebar
      </SidebarContent>
    </Sidebar>
  );
}
```

Great! Now we have the backbone of our application. In your browser, you should see something like this:

![Basic Layout](/assets/chapter-2-layout.png)

## Creating the Chat Storage

Next, we'll create the code for storing chats. First, we need to define a `Chat` type. Create a new folder and file at `types/chat.ts` with this content:

```typescript fileName=types/chat.ts
export type Chat = {
  id: number;
  title: string;
  timestamp: string;
};
```

Next, we'll add a simple in-memory storage with database functions. Create `db/chat.ts` with the following content:

```typescript fileName=db/chat.ts
import 'server-only';
import { Chat } from "@/types/chat";
import { cacheTag, updateTag } from "next/cache";

const chats: Chat[] = [];

export async function getChats() {
  'use cache'
  cacheTag('chats');
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  return chats;
}

export async function createChat(title: string) {
  await new Promise(resolve => setTimeout(resolve, 1000));
  const newChat: Chat = { id: chats.length + 1, title, timestamp: new Date().toISOString() }
  chats.push(newChat);
  updateTag('chats');
  return newChat;
}
```

We've created two functions here:

- **`getChats`** - Retrieves chats from the local `chats` array. Note that we're using `use cache` and `cacheTag` directives. This makes any component using it a cached static component.
- **`createChat`** - Creates a new chat. Note that at the end we call `updateTag`, which invalidates the cached page and triggers a re-fetch.

Also notice `import 'server-only';` at the top. This prevents these functions from being used in client components, ensuring we don't accidentally call them from the browser.

<Woz
title="Any questions?"
description="Do you have any issues or questions so far? You can always ask Woz!"
placeholder="Why is it so complicated, Woz?"/>

## Creating Server Actions

Now we have database-related code, let's add some actions! Create a folder `actions` and a file `actions/chat.ts` inside it with this content:

```typescript fileName=actions/chat.ts
'use server';

import { createChat } from "@/db/chat";

export async function createChatAction(title: string) {
  await createChat(title);
}
```

The first thing you'll notice is the `use server` directive. This tells Next.js that the code in this file contains Server Functions (also known as Server Actions). When Next.js sees this, it automatically creates API endpoints under the hood that client components can call simply by invoking `createChatAction`. Magic!

## Fetching Data

Now we have all the infrastructure needed to connect it to our components. Go to `app/layout.tsx` and add `getChats` as follows:

```typescript add={6,24,29-30,38} remove={23,37} hide={9-22,40-46} fileName=app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { SidebarProvider } from "@/components/ui/sidebar";
import ChatSidebar from "@/components/ChatSidebar";
import { getChats } from "@/db/chat";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const chats = await getChats();

  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <SidebarProvider>
          <ChatSidebar />
          <ChatSidebar chats={chats} />
          <main className="flex-1 overflow-auto">
            {children}
          </main>
        </SidebarProvider>
      </body>
    </html>
  );
}
```

As you can see, we made several changes:
- Made `RootLayout` an async server component (required to use `await getChats()`)
- Added `getChats()` call to fetch chats
- Passed the `chats` data to `ChatSidebar`

## Displaying Chats

Now let's update `components/ChatSidebar.tsx` to display the chats:

```typescript add={2-3,6,11-43} remove={5,9-10} fileName=components/ChatSidebar.tsx
import { Sidebar, SidebarContent } from "./ui/sidebar";
import { MessageSquare } from "lucide-react";
import { Chat } from "@/types/chat";
 
export default function ChatSidebar() {
export default function ChatSidebar({ chats }: { chats: Chat[] }) {
   return (
     <Sidebar>
      <SidebarContent>
        Hello Sidebar
      <SidebarContent className="flex flex-col gap-4 p-4">
        <div className="flex flex-col gap-2">
          <h2 className="text-sm font-semibold text-muted-foreground px-2">
            Recent Chats
          </h2>
          {chats.length > 0 ? (
            <div className="flex flex-col gap-1">
              {chats.map((chat) => (
                <button
                  key={chat.id}
                  className="flex items-start gap-3 rounded-lg px-3 py-2.5 text-left hover:bg-accent transition-colors"
                >
                  <MessageSquare className="size-4 mt-0.5 shrink-0 text-muted-foreground" />
                  <div className="flex flex-col gap-0.5 min-w-0 flex-1">
                    <span className="text-sm font-medium truncate">
                      {chat.title}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {chat.timestamp}
                    </span>
                  </div>
                </button>
              ))}
            </div>
          ) : (
            <div className="flex flex-col items-center justify-center py-8 px-4 text-center">
              <MessageSquare className="size-8 text-muted-foreground/50 mb-2" />
              <p className="text-sm text-muted-foreground">
                No chats yet. Start a new conversation!
              </p>
            </div>
          )}
        </div>
       </SidebarContent>
     </Sidebar>
   );
```

What we've done here is iterate over the received chats and create an item for each one. If there are no chats, we display a "no chats" message.

You should see something like this:

![No chats image](/assets/chapter-2-empty.png)

## Creating a New Chat

Now let's add the ability to create new chats! Add a new section at the start of the `<SidebarContent>` component: 

```typescript add={2-3,5,10-23} remove={1} fileName=components/ChatSidebar.tsx
...
import { MessageSquare } from "lucide-react";
import { Button } from "./ui/button";
import { Plus, MessageSquare } from "lucide-react";
import { Chat } from "@/types/chat";
import { createChatAction } from "@/actions/chat";

...

       <SidebarContent className="flex flex-col gap-4 p-4">
        <div className="flex flex-col gap-3">
          <h1 className="text-xl font-bold">Chat App</h1>

          <form action={createChatAction.bind(null, 'New Chat')}>
            <Button
              className="w-full justify-start gap-2"
              variant="outline"
              type="submit"
            >
              <Plus className="size-4" />
              New Chat
            </Button>
          </form>
        </div>
        <div className="flex flex-col gap-2">
...
```

What did we do here? First, we imported `createChatAction` and set it as the action for the `<form>` component. Inside the form, there's a **New Chat** button that triggers form submission and calls our Server Action.

> **What is `.bind()` and what does it do?**
>
> Here's some JavaScript magic: `.bind()` creates a new function with a specified `this` context (first parameter) and pre-filled arguments. In this case, we're adding the `'New Chat'` title argument to the action without creating an arrow function.

Now you can test it! Click the **New Chat** button in your browser. After a few clicks, you should see a similar view:

![Chats image](/assets/chapter-2-chats.png)

## Better Storage

Now we can create and view chats, but there are some problems with our current approach:
- Chats are not persistent
- Chats get removed when code changes (try modifying the code to see this happen)

Why does this happen? It's because of how Next.js is built. All Next.js server functions are designed to run in a serverless environment. This means each backend call runs on a separate instance, so the `chats` variable gets reset to an empty array on each new instance.

We need a better approach. Normally you would use a database or cloud storage, but for this course we'll store data locally as a file. This will persist through refreshes and across server function calls.

Let's get started! First, we need to create utilities for file storage. Create `lib/fileUtils.ts` with the following content:

```typescript fileName=lib/fileUtils.ts
import fs from 'fs/promises';
import path from 'path';

async function ensureDataDir(fileName: string) {
  const dir = path.dirname(path.join(process.cwd(), 'data', fileName));
  try {
    await fs.access(dir);
  } catch {
    await fs.mkdir(dir, { recursive: true });
  }
}

export async function readContent<T>(fileName: string): Promise<T | null> {
  try {
    await ensureDataDir(fileName);
    const data = await fs.readFile(
      path.join(process.cwd(), 'data', fileName),
      'utf-8'
    );
    return JSON.parse(data);
  } catch (error) {
    // If file doesn't exist or is invalid, return empty array
    return null;
  }
}

export async function writeContent<T>(fileName: string, content: T): Promise<void> {
  await ensureDataDir(fileName);
  await fs.writeFile(
    path.join(process.cwd(), 'data', fileName),
    JSON.stringify(content, null, 2),
    'utf-8'
  );
}
```

This utility provides two functions:
- **`readContent`** - Reads and parses JSON data from a file, creating the directory if it doesn't exist
- **`writeContent`** - Writes data to a file as formatted JSON

Next, we need to update our `db/chat.ts` functions to use these utilities:

```typescript remove={5,13,19} add={6,14,20-25,27} fileName=db/chat.ts
import 'server-only';
import { Chat } from "@/types/chat";
import { cacheTag, updateTag } from "next/cache";

const chats: Chat[] = [];
import { readContent, writeContent } from '@/lib/fileUtils';
 
export async function getChats() {
  'use cache'
  cacheTag('chats');
  
  await new Promise(resolve => setTimeout(resolve, 1000));
  return chats;
  return await readContent<Chat[]>('chats.json') ?? [];
}
 
export async function createChat(title: string) {
  await new Promise(resolve => setTimeout(resolve, 1000));
  const newChat: Chat = { id: chats.length + 1, title, timestamp: new Date().toISOString() }
  const chats = (await readContent<Chat[]>('chats.json')) ?? [];
  const newChat: Chat = { 
    id: chats.length > 0 ? Math.max(...chats.map(c => c.id)) + 1 : 1, 
    title, 
    timestamp: new Date().toISOString() 
  };
  chats.push(newChat);
  await writeContent<Chat[]>('chats.json', chats);
  updateTag('chats');
  return newChat;
}
```

Key changes we made:
- Removed the in-memory `chats` array
- `getChats()` now reads from `chats.json` file
- `createChat()` reads existing chats, generates a proper ID (using the maximum existing ID + 1), adds the new chat, and writes back to the file

Now when you add chats and refresh the page, they should persist. Great work!

<Woz
title="Test Your Knowledge"
description="Let's check with Woz if you were paying attention!"
context={`Ask user the following questions, one by one:
1. What is the new Next.js directive 'use cache' for and when can we use it?
2. How do you update previously cached content with 'use cache'?
3. What is the 'use server' directive for and what does it do?
`}
prompt="Ask me! I know everything!"/>

## Next Steps

Great! We now have our first working feature. Users can create and view chat objects. Remember, this isn't just frontend code - we already have a backend with server components, server actions, and caching!