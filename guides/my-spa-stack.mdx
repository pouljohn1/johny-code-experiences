---
title: "My SPA stack"
description: "Overview of the technology stack behind my domalert.pl SPA: web, mobile, backend, workers, database, and devops."
---

This guide gives a structured tour of the stack I use to run domalert.pl: from monorepo layout and hosting, to backend, frontend, mobile, and workers.

<AiImage prompt="An image presenting React Frontend developer with his technology stack" id="4f3c9115b187f2d88d6fb6637a187a640b95b0beb6cbf8694d2c19826097fe4b" />

## Why the stack matters

Before diving into individual tools, it helps to understand **why** the stack is important:

* It defines **how fast** you can ship.
* It impacts **reliability**, **scalability**, and **cost**.
* It shapes the **developer experience** and how easy it is to maintain the codebase.

My goal with this setup is:

* Use **modern, productive tools**.
* Keep **costs low** but leave room to scale.
* Reuse **as much code as possible** across web, mobile, and backend.

## High-level components

The stack is organized around a few major parts:

* **Web** â€“ the main browser UI where users manage their alerts.
* **Mobile** â€“ a crossâ€‘platform app for iOS and Android.
* **Backend** â€“ APIs, business logic, and integrations.
* **Workers** â€“ background jobs for scraping and processing.
* **Database** â€“ persistent storage for all application data.
* **DevOps** â€“ hosting, deployment, and infrastructure tooling.

These all live together in a single **monorepo**, which keeps shared code and types in one place.

## Monorepo structure with Bun workspaces

All code lives in one repository, managed via **Bun workspaces**.

Why a monorepo?

* **Shared code**: models, utilities, and types are reused across backend, web, and mobile.
* **Single dependency graph**: easier upgrades and consistent versions.
* **Simpler onboarding**: one repo to clone, one place to search.

Why **Bun** instead of plain Node + npm?

* It is **fast** (package installs, scripts, and dev server startâ€‘up).
* Acts as a **runtime**, test runner, and package manager.
* Has builtâ€‘in support for workspaces.

Typical folder structure:

```bash
packages/
â”œâ”€â”€ common/          # Shared utilities, domain logic, helpers
â”œâ”€â”€ common-frontend/ # Shared UI logic, hooks, and components
â”œâ”€â”€ db-schema/       # Prisma schema, migrations, DB models
â”œâ”€â”€ backend/         # API server and background tasks entrypoints
â”œâ”€â”€ jobs/            # One-off or scheduled jobs reusing multiple packages
â”œâ”€â”€ mobile/          # React Native / Expo app
â”œâ”€â”€ web/             # Web SPA built with React + Vite
â””â”€â”€ worker/          # Scraping and data processing workers
```

This layout makes it clear where each concern lives while supporting heavy sharing of types and logic.

## DevOps and hosting

### Backend and database

For backend and database hosting I use **Hetzner Cloud**:

* **Affordable** â€“ good performance at a low price point.
* **Flexible** â€“ easy to resize servers as usage grows.
* **Simple networking** â€“ private networks and firewalls are straightforward.

On top of the raw servers I run **Coolify**:

* Openâ€‘source alternative to Heroku.
* Provides a nice UI for deploying containers and apps.
* Manages databases and environment variables.

Typical responsibilities:

* Run the **backend API** service.
* Host the **PostgreSQL** database.
* Run supporting services like **Redis**.

### Web hosting

The web SPA is deployed on **Vercel**:

* Excellent **DX** for React + Vite/Nextâ€‘style frontends.
* **Fast global CDN** and edge network.
* Automatic **preview deployments** for each branch.

Vercel pulls from the monorepo and only builds the `web` package, keeping deployments fast and isolated.

### Mobile delivery

For the mobile app I use **Expo**:

* Build **iOS, Android, and web** from mostly the same code.
* Great tooling: overâ€‘theâ€‘air updates, dev client, and build services.
* Strong ecosystem for push notifications, deep linking, etc.

The mobile app pulls shared logic from `common/` and `common-frontend/`, which keeps behavior consistent with the web app.

## Backend stack

The backend focuses on clear APIs, strong typing, and performance.

### Core technologies

* **Bun** â€“ the runtime for the backend and workers.
  * Nearly **Node-compatible**, but significantly faster in many cases.
  * Runs scripts, tests, and the API server.
* **Express.js** â€“ minimalist web framework.
  * Simple routing and middleware.
  * Huge ecosystem of existing middlewares.
* **Prisma** â€“ typeâ€‘safe ORM for PostgreSQL.
  * Schemaâ€‘driven: the `schema.prisma` file is the single source of truth.
  * Generates fully typed client code.
  * Handles migrations cleanly.
* **PostgreSQL** â€“ main relational database.
  * Strong consistency, relational modeling.
  * Rich query capabilities.
* **Redis** â€“ inâ€‘memory data store.
  * Used for **caching**, **rate limiting**, and **ephemeral state**.
* **Stripe** â€“ payments and subscriptions.
  * Handles billing, invoices, and subscription cycles.
  * Webhooks connect Stripe events back to the backend.
* **AWS S3 (or compatible storage)** â€“ file storage.
  * Stores userâ€‘uploaded images and media.
  * Serves as a durable, cheap object store.
* **OpenAI API** â€“ AIâ€‘assisted features.
  * Compares **similar estates**.
  * Helps surface potentially good deals.

### Typical backend responsibilities

* Authentication and authorization.
* CRUD APIs over estate data, alerts, and users.
* Payment and subscription management via Stripe.
* Data enrichment and AIâ€‘powered comparisons.
* Webhooks handling (Stripe, scraping results, etc.).

## Frontend (web) stack

The web SPA is tuned for fast development and good UX.

### Core technologies

* **Vite**
  * Extremely fast dev server with HMR.
  * Simple configuration compared to older bundlers.
* **TypeScript**
  * Static types across the whole frontend.
  * Safer refactors and richer editor support.
* **React**
  * Declarative UI composition.
  * Works well with both the web and native stacks.
* **MUI (Material UI)**
  * Preâ€‘built, accessible React components.
  * Consistent design system out of the box.
  * Saves time on basic layout, inputs, and navigation.
* **react-map-gl**
  * React wrapper for **Mapbox GL JS**.
  * Renders interactive maps with estate markers.
  * Supports panning, zooming, clustering, and custom overlays.

### Frontend responsibilities

* Search and filter experiences for estates.
* Mapâ€‘based browsing and selection.
* User onboarding, login, and settings.
* Managing alerts and notifications.

## Mobile stack

The mobile app shares as much logic and types as possible with the web, but targets native platforms.

### Core technologies

* **Expo**
  * Handles native builds, OTA updates, and device testing.
  * Provides batteriesâ€‘included APIs (notifications, media, etc.).
* **React Native**
  * Use React components to build native UIs.
  * Large ecosystem of community libraries.
* **TypeScript**
  * Shared models and types with backend and web.
  * Safer crossâ€‘platform refactors.
* **react-native-maps**
  * Native map rendering on iOS and Android.
  * Used to display estates on a map with pins and regions.

### Mobile responsibilities

* Give users onâ€‘theâ€‘go access to their alerts.
* Show nearby or saved estates on the map.
* Handle push notifications for important updates.

## Workers and scraping stack

Workers run outside of the request/response cycle to keep the app responsive.

### What workers do

* **Scrape data** from external sources.
* Normalize and clean raw listings.
* Deduplicate and enrich estates.
* Trigger alerts or notifications based on new data.

### Core technologies

* **Bun**
  * Runs worker scripts fast.
  * Shares code and configuration with the backend.
* **Puppeteer**
  * Headless browser automation library.
  * Used to load pages, handle JavaScriptâ€‘heavy sites, and extract data.

Workers usually:

1. Fetch or render an external page (via Puppeteer).
2. Extract relevant data.
3. Normalize and validate it.
4. Store it via the shared Prisma layer.
5. Optionally queue further work (e.g., AI comparison, notifications).

## How it all fits together

Here is a conceptual flow of data in the system:

1. **Workers** scrape estate data and push it into **PostgreSQL** via **Prisma**.
2. The **backend API** exposes that data to web and mobile clients.
3. **Redis** caches hot data and tracks ephemeral state.
4. **Web** (Vercel) and **mobile** (Expo) apps talk to the backend over HTTP/HTTPS.
5. **Stripe** manages billing; webhooks notify the backend of subscription changes.
6. **OpenAI** is called from the backend to compare estates and suggest deals.
7. Files and images are stored in **S3â€‘compatible** object storage.

The monorepo, shared types, and Bunâ€‘based tooling are what make this multiâ€‘surface setup manageable as a single product.

## Common pitfalls and tradeâ€‘offs

Some tradeâ€‘offs in this stack:

* **Monorepo complexity** â€“ tooling is great but CI and caching require thought.
* **Bun maturity** â€“ fast and promising, but newer than Node; some packages may need workarounds.
* **Scraping maintenance** â€“ external sites change HTML and structures, breaking scrapers.
* **Vendor mix** â€“ Hetzner, Vercel, Expo, AWS, Stripe, and OpenAI each have their own dashboards and limits.

Despite these, the stack gives a strong balance of **speed**, **cost control**, and **developer happiness** for a solo or small team project.

## Final notes

This was a highâ€‘level overview of the technology stack behind domalert.pl. In future guides I plan to:

* Deepâ€‘dive into the **backend architecture** and key patterns.
* Explain the **scraping pipeline** endâ€‘toâ€‘end.
* Show how I structure shared code between **web** and **mobile**.

If you have questions or want more detail about a specific layer, this overview should give you the vocabulary to ask precisely what youâ€™re curious about. Thanks!

<Woz title="Recap" description="Make sure you really understand ðŸ™ƒ" prompt="Ask me 3 specific questions about this stack: one about hosting, one about the monorepo structure, and one about a particular technology choice and its role." />